%% INTEGRATA: Percorso Ottimo e Dinamica del Platoon con verifica semafori e plot finale delle traiettorie
clear; clc; close all;

%% ========================
%% SEZIONE A: Percorso Ottimo (Profilo del Leader)
%% ========================
% Parametri di simulazione del percorso ottimo
final_time = 150;         % Tempo totale (s)
final_distance = 1800;    % Distanza finale (m)
T = 30;                   % Durata del ciclo del semaforo (s)
tf = final_time;

% Limiti di velocità (m/s)
v_min = 5;   
v_max = 30;  

% Parametri per il calcolo dell'energia (esemplificativi)
b1 = 0.1;  b2 = 0.01;
accel = 1000;  % accelerazione usata per decelerazione

% Velocità iniziale del leader
initial_speed = 0;

% Creazione dei semafori
traffic_lights = [ ...
    create_traffic_light(300, 0, 10, T); ...
    create_traffic_light(600, 10, 20, T); ...
    create_traffic_light(900, 20, 30, T); ...
    create_traffic_light(1200, 0, 10, T); ...
    create_traffic_light(1550, 10, 20, T) ...
];

% Costruzione del grafo per il percorso ottimo
[t_min, t_max] = velocity_pruning(traffic_lights, tf, final_distance, v_min, v_max);
d_light = [traffic_lights.distance]; 
nIntersections = length(traffic_lights);
Nodes = struct('id', {}, 't', {}, 'd', {}, 'int', {});
nodeId = 1;
Nodes(nodeId) = struct('id', nodeId, 't', 0, 'd', 0, 'int', 0); % sorgente
nodeId = nodeId + 1;
for i = 1:nIntersections
    light = traffic_lights(i);
    for k = 0:ceil(tf / light.cycle_time)
        cycle_start = k * light.cycle_time + light.offset;
        green_start_cycle = light.green_start;
        green_end_cycle = light.green_end;
        if green_start_cycle <= green_end_cycle
            abs_green_start = cycle_start + green_start_cycle;
            abs_green_end = cycle_start + green_end_cycle;
            if abs_green_start <= tf
                overlap_start = max(abs_green_start, t_min(i));
                overlap_end = min(abs_green_end, t_max(i));
                if overlap_start < overlap_end
                    middle_time = ceil((overlap_start+overlap_end)/2);
                    Nodes(nodeId) = struct('id', nodeId, 't', middle_time, 'd', d_light(i), 'int', i);
                    nodeId = nodeId + 1;
                end
            end
        else  % caso wrap-around
            abs_green_start_1 = cycle_start + green_start_cycle;
            abs_green_end_1 = cycle_start + light.cycle_time;
            if abs_green_start_1 <= tf
                overlap_start = max(abs_green_start_1, t_min(i));
                overlap_end = min(abs_green_end_1, t_max(i));
                if overlap_start < overlap_end
                    middle_time = (overlap_start+overlap_end)/2;
                    Nodes(nodeId) = struct('id', nodeId, 't', middle_time, 'd', d_light(i), 'int', i);
                    nodeId = nodeId + 1;
                end
            end
            abs_green_start_2 = cycle_start;
            abs_green_end_2 = cycle_start + green_end_cycle;
            if abs_green_end_2 <= tf
                overlap_start = max(abs_green_start_2, t_min(i));
                overlap_end = min(abs_green_end_2, t_max(i));
                if overlap_start < overlap_end
                    middle_time = (overlap_start+overlap_end)/2;
                    Nodes(nodeId) = struct('id', nodeId, 't', middle_time, 'd', d_light(i), 'int', i);
                    nodeId = nodeId + 1;
                end
            end
        end
    end
end
Nodes(nodeId) = struct('id', nodeId, 't', tf, 'd', final_distance, 'int', nIntersections+1);
nNodes = nodeId;

% Costruzione degli archi
Edges = struct('from', {}, 'to', {}, 'w', {});
edgeCount = 1;
for i = 1:nNodes
    current_level = Nodes(i).int;
    for j = 1:nNodes
        next_level = Nodes(j).int;
        if next_level == current_level + 1
            if Nodes(j).t > Nodes(i).t && Nodes(j).d > Nodes(i).d
                if Nodes(j).int > 0 && Nodes(j).int <= nIntersections
                    if ~is_green(traffic_lights(Nodes(j).int), Nodes(j).t)
                        continue;
                    end
                end
                delta_t = Nodes(j).t - Nodes(i).t;
                delta_d = Nodes(j).d - Nodes(i).d;
                v_link = delta_d / delta_t;
                if v_link >= v_min && v_link <= v_max
                    E_link = delta_t * (b1*v_link + b2*v_link^2);
                    w = E_link;
                    Edges(edgeCount) = struct('from', Nodes(i).id, 'to', Nodes(j).id, 'w', w);
                    edgeCount = edgeCount + 1;
                end
            end
        end
    end
end

[path, cost] = dijkstra(Nodes, Edges, Nodes(1).id, Nodes(end).id);
fprintf('Costo energetico ottimo (leader): %f\n', cost);
fprintf('Percorso ottimo (node id, t, d):\n');
for k = 1:length(path)
    n_idx = path(k);
    fprintf('Node %d: t = %.2f s, d = %.2f m\n', Nodes(n_idx).id, Nodes(n_idx).t, Nodes(n_idx).d);
end
opt_nodes = Nodes(path);

% Calcolo del profilo del leader: tempo, distanza e velocità
dt = 0.01;
[t_leader, d_leader, v_leader] = simulate_vehicle_segmented(opt_nodes, dt, traffic_lights, initial_speed, accel);

% Creiamo una funzione di riferimento per il leader (velocità desiderata)
leader_ref = @(t_query) interp1(t_leader, v_leader, t_query, 'linear', 'extrap');

%% ========================
%% SEZIONE B: Dinamica del Platoon (ODE45 con PID)
%% ========================
% Parametri per il modello dinamico
n_vehicles = 3;         % Leader + follower
m = 1000 * ones(1, n_vehicles);  % Masse uguali
% Parametri per forze esterne
b1_ext = 450; b2_ext = 450; b3_ext = 1; b4_ext = 3;
delta = @(t) 0 * (b1_ext + b2_ext*(sin((1/b3_ext)*t+b4_ext) + 0.25*rand)); % forza esterna (qui disattivata)

% Condizioni iniziali: posizioni e velocità
d_init = 1;   % separazione di base (m)
x0 = zeros(2*n_vehicles,1);
x0(1) = 0; % leader in posizione 0
for i = 2:n_vehicles
    x0(i) = -d_init * (i-1);
end

% Parametri PID:
% Leader: controllo velocità basato sul riferimento leader_ref
K_p_speed = 7000; K_i_speed = 0; K_d_speed = 0.7;
% Follower: controllo distanza rispetto al veicolo anteriore
K_p_dist  = 2000; K_i_dist = 0.8; K_d_dist = 0.4;
t_CTH = 1.5;  % tempo di separazione desiderato

% Simulazione dinamica con ode45
tspan = [0 30];
[t_dyn, x] = ode45(@(t,x) system_dynamics(t,x, n_vehicles, m, delta, d_init, leader_ref, t_CTH, ...
    K_p_speed, K_i_speed, K_d_speed, K_p_dist, K_i_dist, K_d_dist), tspan, x0);

%% Grafici dei risultati della dinamica (ODE45)
figure;
for i = 1:n_vehicles
    % Velocità per il veicolo i
    subplot(2, n_vehicles, i);
    plot(t_dyn, x(:, n_vehicles+i), 'LineWidth',1.5);
    title(['Velocità veicolo ' num2str(i)]);
    xlabel('Tempo [s]'); ylabel('Vel [m/s]');
    grid on;
    
    % Posizione per il veicolo i
    subplot(2, n_vehicles, n_vehicles+i);
    plot(t_dyn, x(:, i), 'LineWidth',1.5);
    title(['Posizione veicolo ' num2str(i)]);
    xlabel('Tempo [s]'); ylabel('Pos [m]');
    grid on;
end

% Grafico delle distanze (tra leader e follower)
figure;
hold on;
for i = 2:n_vehicles
    distance_i = x(:,1) - x(:, i);
    plot(t_dyn, distance_i, 'LineWidth',1.5, 'DisplayName', sprintf('Distanza V%d-V%d', i-1, i));
end
legend('show'); grid on;
xlabel('Tempo [s]'); ylabel('Distanza [m]');
title('Distanza fra Leader e Follower');

%% Verifica passaggio ai semafori per ogni veicolo
fprintf('\nVerifica passaggio ai semafori durante la simulazione ODE45:\n');
for veh = 1:n_vehicles
    traj.t = t_dyn;
    traj.d = x(:, veh);
    for i = 1:length(traffic_lights)
        light = traffic_lights(i);
        if traj.d(end) < light.distance
            continue;
        end
        t_cross = interp1(traj.d, traj.t, light.distance);
        if ~is_green(light, t_cross)
            fprintf('Veicolo %d: Al semaforo a %.0f m, al tempo %.2f s, il semaforo NON è verde!\n', veh, light.distance, t_cross);
        else
            fprintf('Veicolo %d: Semaforo a %.0f m passato in verde (al tempo %.2f s).\n', veh, light.distance, t_cross);
        end
    end
end

%% ========================
%% PLOT FINALE: Traiettorie di Tutti i Veicoli
%% ========================
figure;
hold on;
colors = lines(n_vehicles);
for i = 1:n_vehicles
    plot(t_dyn, x(:, i), 'Color', colors(i,:), 'LineWidth',2, 'DisplayName', ['Veicolo ' num2str(i)]);
end
xlabel('Tempo [s]');
ylabel('Posizione [m]');
title('Traiettorie dei veicoli nel tempo');
legend('show');
grid on;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FUNZIONI LOCALI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function light = create_traffic_light(distance, green_start, green_end, cycle_time)
    light.distance = distance;
    light.green_start = green_start;
    light.green_end = green_end;
    light.cycle_time = cycle_time;
    light.green_duration = green_end - green_start;
    light.offset = mod(green_start, cycle_time);
end

function status = is_green(light, time)
    time_in_cycle = mod(time - light.offset, light.cycle_time);
    if light.green_start <= light.green_end
        status = (time_in_cycle >= light.green_start) && (time_in_cycle < light.green_end);
    else
        status = (time_in_cycle >= light.green_start) || (time_in_cycle < light.green_end);
    end
end

function [t_min, t_max] = velocity_pruning(traffic_lights, tf, final_distance, v_min, v_max)
    n = length(traffic_lights);
    t_min = zeros(1, n); t_max = zeros(1, n);
    d = [traffic_lights.distance];
    
    t_min(1) = d(1)/v_max;
    t_max(1) = d(1)/v_min;
    t_min(1) = next_green(traffic_lights(1), t_min(1));
    t_max(1) = prev_green(traffic_lights(1), t_max(1));
    for i = 2:n
        dt_val = d(i)-d(i-1);
        t_min(i) = t_min(i-1) + dt_val/v_max;
        t_max(i) = t_max(i-1) + dt_val/v_min;
        t_max(i) = min(t_max(i), tf - (final_distance-d(i))/v_max);
        t_min(i) = next_green(traffic_lights(i), t_min(i));
        t_max(i) = prev_green(traffic_lights(i), t_max(i));
    end
    for i = n:-1:2
        if t_max(i) > t_max(i-1) + (d(i)-d(i-1))/v_max
            t_max(i-1) = t_max(i) - (d(i)-d(i-1))/v_max;
            t_max(i-1) = prev_green(traffic_lights(i-1), t_max(i-1));
        end
    end
end

function t_next = next_green(light, t)
    if is_green(light, t)
        t_next = t;
    else
        time_in_cycle = mod(t - light.offset, light.cycle_time);
        if time_in_cycle < light.green_start
            t_next = t + (light.green_start - time_in_cycle);
        else
            t_next = t + (light.cycle_time - time_in_cycle) + light.green_start;
        end
    end
end

function t_prev = prev_green(light, t)
    if is_green(light, t)
        t_prev = t;
    else
        time_in_cycle = mod(t - light.offset, light.cycle_time);
        if time_in_cycle >= light.green_end
            t_prev = t - (time_in_cycle - light.green_end);
        else
            t_prev = t - time_in_cycle - (light.cycle_time - light.green_end);
        end
    end
end

function draw_vehicle_path_simulation(tf, final_distance, traffic_lights, v_min, v_max)
    [t_min, ~] = velocity_pruning(traffic_lights, tf, final_distance, v_min, v_max);
    d = [traffic_lights.distance];
    traj_t = [0, t_min, tf];
    traj_d = [0, d, final_distance];
    plot(traj_t, traj_d, 'b-', 'LineWidth',2);
end

function draw_vehicle_path_simulation_max(tf, final_distance, traffic_lights, v_min, v_max)
    [~, t_max] = velocity_pruning(traffic_lights, tf, final_distance, v_min, v_max);
    d = [traffic_lights.distance];
    traj_t = [0, t_max, tf];
    traj_d = [0, d, final_distance];
    plot(traj_t, traj_d, 'b-', 'LineWidth',2);
end

function [path, cost] = dijkstra(Nodes, Edges, source, target)
    nNodes = length(Nodes);
    cost = inf(1, nNodes); prev = nan(1, nNodes);
    cost(source) = 0;
    Q = 1:nNodes;
    while ~isempty(Q)
        [~, idx] = min(cost(Q));
        u = Q(idx); Q(Q==u) = [];
        if u == target, break; end
        for e = Edges
            if e.from == u
                v = e.to;
                alt = cost(u) + e.w;
                if alt < cost(v)
                    cost(v) = alt; prev(v) = u;
                end
            end
        end
    end
    path = [];
    u = target;
    if ~isnan(prev(u)) || u == source
        while ~isnan(u)
            path = [u, path];
            u = prev(u);
        end
    end
end

function [t_sim, d_sim, v_sim] = simulate_vehicle_segmented(opt_nodes, dt, traffic_lights, init_speed, accel)
    t_sim = []; 
    d_sim = []; 
    v_sim = [];
    currentTime = 0; 
    currentDist = 0; 
    currentSpeed = init_speed;
    
    t_sim(end+1) = currentTime; 
    d_sim(end+1) = currentDist; 
    v_sim(end+1) = currentSpeed;
    
    for i = 2:length(opt_nodes)
        % ...existing code per calcolo T_seg, D_seg, v_req, ecc...
        
        if currentSpeed > v_req
            % --- Fase di decelerazione ---
            % ...existing code (calcolo t_vec_dec, d_vec_dec, ecc.)...
            
            t_seg_vect = [];
            d_seg_vect = [];
            v_seg_vect = [];
            
            % Se esistono almeno 2 elementi, applichiamo (2:end), altrimenti prendiamo tutto
            if numel(t_vec_dec) > 1
                t_seg_vect = [t_seg_vect, t_vec_dec(2:end)];
                d_seg_vect = [d_seg_vect, d_vec_dec(2:end)];
                v_seg_vect = [v_seg_vect, v_vec_dec(2:end)];
            else
                t_seg_vect = [t_seg_vect, t_vec_dec];
                d_seg_vect = [d_seg_vect, d_vec_dec];
                v_seg_vect = [v_seg_vect, v_vec_dec];
            end
            
            if numel(t_vec_const) > 1
                t_seg_vect = [t_seg_vect, t_vec_const(2:end)];
                d_seg_vect = [d_seg_vect, d_vec_const(2:end)];
                v_seg_vect = [v_seg_vect, v_vec_const(2:end)];
            else
                t_seg_vect = [t_seg_vect, t_vec_const];
                d_seg_vect = [d_seg_vect, d_vec_const];
                v_seg_vect = [v_seg_vect, v_vec_const];
            end
            
            if numel(t_vec_wait) > 1
                t_seg_vect = [t_seg_vect, t_vec_wait(2:end)];
                d_seg_vect = [d_seg_vect, d_vec_wait(2:end)];
                v_seg_vect = [v_seg_vect, v_vec_wait(2:end)];
            else
                t_seg_vect = [t_seg_vect, t_vec_wait];
                d_seg_vect = [d_seg_vect, d_vec_wait];
                v_seg_vect = [v_seg_vect, v_vec_wait];
            end
            
            % ...existing code (aggiornamenti di currentSpeed, currentTime, ecc.)...
            
        else
            % --- Fase di velocità costante ---
            % ...existing code (calcolo t_vec, d_vec, ecc.)...
            
            if numel(t_vec) > 1
                t_seg_vect = t_vec(2:end);
                d_seg_vect = d_vec(2:end);
                v_seg_vect = v_vec(2:end);
            else
                t_seg_vect = t_vec;
                d_seg_vect = d_vec;
                v_seg_vect = v_vec;
            end
            % ...existing code (aggiornamenti di currentSpeed, currentTime, ecc.)...
        end
        
        % --- Attesa al semaforo se rosso ---
        % ...existing code...
        % Stesso controllo (numel(...) > 1) se occorre aggiungere (2:end).
        
        t_sim = [t_sim, t_seg_vect];
        d_sim = [d_sim, d_seg_vect];
        v_sim = [v_sim, v_seg_vect];
    end
end
function dx = system_dynamics(t, x, n_vehicles, m, delta, d_min, leader_ref, t_CTH, ...
    K_p_speed, K_i_speed, K_d_speed, K_p_dist, K_i_dist, K_d_dist)
% Sistema dinamico per il platoon:
% - Leader: riferimento di velocità (leader_ref) per PID
% - Follower: controllo PID sulla distanza dal veicolo anteriore
    dx = zeros(2*n_vehicles, 1);
    dt = 0.01;  % passo fisso per il calcolo PID
    
    persistent error_integral_speed previous_error_speed
    persistent error_integral_dist previous_error_dist
    if isempty(error_integral_speed) || isempty(error_integral_dist)
        error_integral_speed = 0;
        previous_error_speed = 0;
        error_integral_dist = zeros(n_vehicles,1);
        previous_error_dist = zeros(n_vehicles,1);
    end
    
    for i = 1:n_vehicles
        % Derivata della posizione = velocità
        dx(i) = x(n_vehicles+i);
        if i == 1
            %% LEADER: controllo PID sulla velocità con riferimento leader_ref
            desired_speed = leader_ref(t);
            velocity_error = desired_speed - x(n_vehicles+1);
            error_integral_speed = error_integral_speed + velocity_error*dt;
            velocity_derivative = (velocity_error - previous_error_speed)/dt;
            U_leader = K_p_speed * velocity_error + ...
                       K_i_speed * error_integral_speed + ...
                       K_d_speed * velocity_derivative;
            previous_error_speed = velocity_error;
            dx(n_vehicles+1) = (U_leader + delta(t))/m(1);
            max_speed = 30;
            current_speed = x(n_vehicles+1) + dx(n_vehicles+1)*dt;
            if current_speed < 0
                current_speed = 0;
            elseif current_speed > max_speed
                current_speed = max_speed;
            end
            dx(n_vehicles+1) = (current_speed - x(n_vehicles+1))/dt;
        else
            %% FOLLOWER: controllo PID sulla distanza dal veicolo anteriore
            distance = x(i) - x(i-1);
            v_prev = x(n_vehicles + i - 1);
            desired_distance = -(d_min + t_CTH*v_prev);
            dist_error = desired_distance - distance;
            error_integral_dist(i) = error_integral_dist(i) + dist_error*dt;
            distance_derivative = (dist_error - previous_error_dist(i))/dt;
            previous_error_dist(i) = dist_error;
            U_dist = K_p_dist*dist_error + K_i_dist*error_integral_dist(i) + K_d_dist*distance_derivative;
            dx(n_vehicles+i) = U_dist/m(i);
            hypothetic_speed = x(n_vehicles+i) + dx(n_vehicles+i)*dt;
            if hypothetic_speed < 0
                hypothetic_speed = 0;
            end
            dx(n_vehicles+i) = (hypothetic_speed - x(n_vehicles+i))/dt;
        end
    end
end